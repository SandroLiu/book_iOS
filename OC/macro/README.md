# Macro

学习宏之前先掌握一个标准C的赋值扩展
- 格式：({....})
- 作用：在顺次执行之后会将最后一次的表达式的赋值作为返回

代码清单
```objc
    int a = ({
        int b = 1;
        int c = 2;
        b + c;
    });
    // => a is 3
```
这段代码执行完毕后a的值为3，而且b和c只存在于大括号限定的代码域中。

## 分类
宏分为对象宏(object-like macro)和函数宏(function-like macro)

对象宏：对象宏一般用来定义一些常熟
```objc
    #define M_PI 3.1415926
```
函数宏：类似函数，可以接受参数的宏。在定义的时候，如果我们在宏名字后面跟上一对括号的话，这个宏就变成了函数宏。

```objc
    #define SELF(x) x
    NSString *name = @"Macro Rookie";
    NSLog(@"Hello %@", SELF(name));
    // => NSLog(@"Hello %@", name);
    // => Hello Macro Rookie
```
这个宏做的事情是，在编译时如果遇到SELF，并且后面带括号，并且括号中的参数个数与定义的相符，那么就将括号中的参数换到定义的内容里去，然后替换掉原来的内容。 具体到这段代码中，SELF接受了一个name，然后将整个SELF(name)用name替换掉

接受多个参数的宏

```objc
    #define PLUS(x, y) x + y
    printf("%d", PLUS(3, 2));
    // => printf("%d", 3 + 2);
    // => 5
```

## 进阶
宏看似非常简单，只是简单的替换，但是实际开发中有许多地方需要注意，下面就以实际开发中遇到的问题进行了解

实现一个MIN宏，给定两个数字输入，获取较小的那个

实现方法一

```objc
     #define MIN(A, B) A < B ? A : B
```
实际使用一下
```objc
    int a = MIN(1, 2)
    // => a = 1 < 2 ? 1 : 2;
    // => a = 1;
```
再换一个
```objc
    int a = 2 * MIN(3, 4);
    // => a = 2 * 3 < 4 ? 3 : 4;
    // => a = 6 < 4 ? 3 : 4;
    // => a = 4;
```
bug出来了，因为乘法优先级较高所以先计算乘法。那么解决办法添加个括号。
```objc
    #define MIN(A, B) (A < B ? A : B)
```
感觉问题解决了，不过某天问题又来了

```objc
    int a = MIN(3, 4 < 5 ? 4 : 5);
    printf("%d", a);
    // => 4;
```
我们将宏展开，看看原因

```objc

    a = (3 < 4 < 5 ? 4 : 5 ? 3 : 4 < 5 ? 4 : 5); // 这里涉及到了运算符优先级

    // 按照实际优先级添加括号加以区分
    a = ((3 < (4 < 5 ? 4 : 5) ? 3 : 4 )< 5 ? 4 : 5);

    a = ((3 < 4 ? 3 : 4) < 5 ? 4 : 5);

    a = (3 < 5 ? 4 : 5);
    a = 4;
```
原因明白了，还是运算符优先级的问题。我们再次进行修正
```objc
    #define MIN(A, B) ((A) < (B) ? (A) : (B));
```
没过多久问题又来了

```objc
    float a = 1.0f;
    float b = MIN(a++, 1.5f);
    printf("a=%f, b=%f", a, b);
    // => a = 3.000000, b = 2.000000
```
a是1，a++表示先使用a的值进行计算，然后再加1。那么其实这个式子想要计算的是取a和b的最小值，然后a等于a加1：所以正确的输出a为2，b为1才对。
我们将宏展开看看

```objc
    float a = 1.0f;
    float b = MIN(a++, 1.5f);
    // => b = ((a++) < (1.5f) ? (a++) : (1.5f))
```
其实只要展开一步就很明白了，在比较a++和1.5f的时候，先取1和1.5比较，然后a自增1。接下来条件比较得到真以后又触发了一次a++，此时a已经是2，于是b得到2，最后a再次自增后值为3。出错的根源就在于我们预想的是a++只执行一次，但是由于宏展开导致了a++被多执行了，改变了预想的逻辑。

解决这个问题就用到了我们开始提到的标准C的赋值扩展语法。

有了这个扩展，我们就能做到之前很多做不到的事情了。比如彻底解决MIN宏定义的问题，而也正是GNU C中MIN的标准写法

```objc
    #define MIN(A, B) ({__typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __a : __b;});

```
这里定义了三个语句，分别以输入的类型申明了__a和__b，并使用输入为其赋值，接下来做一个简单的条件比较，得到__a和__b中的较小值，并使用赋值扩展将结果作为返回。这样的实现保证了不改变原来的逻辑，先进行一次赋值，也避免了括号优先级的问题，可以说是一个比较好的解决方案了。如果编译环境支持GNU C的这个扩展，那么毫无疑问我们应该采用这种方式来书写我们的MIN宏，如果不支持这个环境扩展，那我们只有人为地规定参数不带运算或者函数调用，以避免出错。

如果在同一个scope内已经有__a或者__b的定义的话（虽然一般来说不会出现这种悲剧的命名，不过谁知道呢），这个宏可能出现问题。在申明后赋值将因为定义重复而无法被初始化，导致宏的行为不可预知

Apple在Clang中彻底解决了这个问题，我们把Xcode打开随便建一个新工程，在代码中输入MIN(1,1)，然后Cmd+点击即可找到clang中 MIN的写法。为了方便说明，我直接把相关的部分抄录如下：
```objc
    //CLANG MIN
#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); __typeof__(B) __NSX_PASTE__(__b,L) = (B); (__NSX_PASTE__(__a,L) < __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); })
```
似乎有点长，看起来也很吃力。我们先美化一下这宏，首先是最后那个__NSMIN_IMPL__内容实在是太长了。我们知道代码的话是可以插入换行而不影响含义的，宏是否也可以呢？答案是肯定的，只不过我们不能使用一个单一的回车来完成，而必须在回车前加上一个反斜杠\。改写一下，为其加上换行好看些：

```objc
#define __NSX_PASTE__(A,B) A##B

#define MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)

#define __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); \
                                 __typeof__(B) __NSX_PASTE__(__b,L) = (B); \
                                 (__NSX_PASTE__(__a,L) < __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); \
                              })
```
但可以看出MIN一共由三个宏定义组合而成。第一个__NSX_PASTE__里出现的两个连着的井号##在宏中是一个特殊符号，它表示将两个参数连接起来这种运算。注意函数宏必须是有意义的运算，因此你不能直接写AB来连接两个参数，而需要写成例子中的A##B。宏中还有一切其他的自成一脉的运算符号，我们稍后还会介绍几个。接下来是我们调用的两个参数的MIN，它做的事是调用了另一个三个参数的宏__NSMIN_IMPL__，其中前两个参数就是我们的输入，而第三个__COUNTER__我们似乎不认识，也不知道其从何而来。其实__COUNTER__是一个预定义的宏，这个值在编译过程中将从0开始计数，每次被调用时加1。因为唯一性，所以很多时候被用来构造独立的变量名称。有了上面的基础，再来看最后的实现宏就很简单了。整体思路和前面的实现和之前的GNUC MIN是一样的，区别在于为变量名__a和__b添加了一个计数后缀，这样大大避免了变量名相同而导致问题的可能性


## Log


