# 面试题

1. 什么是ARC  

ARC是自动引用计数。OC中使用引用计数来管理内存，OC对象中有个引用计数retain count。retain count为0时释放内存，使用alloc copy等创建对象，对象的引用计数会加一。使用release引用计数会减一。早期xcode使用手动引用计数，自己生成的对象要自己释放。ARC下编译器会自动添加内存管理代码，不需要人为释放了。

2. 请解释以下keywords的区别： assign vs weak, __block vs __weak

assign vs weak：都能修饰对象，都不会使对象的引用计数+1，weak修饰对象，当对象释放时会自动使指针置为nil，assign不会。assign可以修饰基本类型，weak不可以。
__block vs __weak：__weak是在ARC下才有的，修饰的变量在block里不会被block强引用。__block在ARC下修饰局部变量使局部变量在block里可以被修改。在MRC里__block修饰变量可以使变量在block不会被强引用。

3. 使用atomic一定是线程安全的吗？
不是。atomic 只会保证setter方法和getter方法的原子性，当多线程对一段代码进行读写操作时就不能保证这段代码是原子性的。多线程的不安全就是同时对同一块内存进行操作得到意料之外的结果。
详情看多线程的不安全讨论工程

4.  +(void)load;   +(void)initialize；有什么用处？
load方法在类被加载进内存后会被调用。
initialize方法会在类或实例收到第一个方法的时候被调用，除了load方法和initialize方法。
load方法是使用函数指针的方式调用，调用顺序是父类->子类->分类，分类与编译顺序有关。子类如果没有实现不会调用父类的实现方法。
initialize方法是使用发送消息的方式调用，调用顺序是先调用父类的方法，再调用子类的方法。如果子类没有实现会调用父类的实现，那么父类的实现会走两次。
注意：initialize方法分类会覆盖掉主类的方法，在分类都没有实现load方法或都实现load方法时，后编译的分类会覆盖掉先编译的分类的方法，实现了load方法的分类会覆盖掉没有实现load方法的分类的实现。

5. 为什么其他语言里叫函数调用， objective c里则是给对象发消息
函数调用，具体调用哪个实现是在编译期就会确定的。而OC中的发送消息调用哪个实现是在运行期间才会确定的。代码中的发送消息会被编译器转化成objc_msgSend(receiver, msg)函数，向接收者发送消息，如果接受者没有实现也可以转发消息。如果都没有实现的话程序就会崩溃。

6. block 和 delegate的区别
    - block回调可以包裹不同的代码段，不用对于不同代码进行区分
    - delgate代码统一写到一处，不同用处的代码也要写到一起，需要进行区分